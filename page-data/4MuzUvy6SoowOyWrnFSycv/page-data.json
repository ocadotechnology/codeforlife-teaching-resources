{"componentChunkName":"component---src-templates-worksheet-js","path":"/4MuzUvy6SoowOyWrnFSycv","result":{"data":{"contentfulWorksheet":{"worksheetTitle":"Teacher Challenge Guide 3","resourceSection":null,"content":[{"__typename":"ContentfulFullWidthText","heading":{"name":"Introduction"},"content":{"content":"## Objectives\n\n* To apply algorithmic thinking to tasks to work out appropriate solutions\n* To expand pupils’ use of selections statements to allow for multiple routes through their code\n* To consolidate knowledge of local variables in subroutines\n* To explore standard solutions such as counting different elements in a list"}},{"__typename":"Contentful2ColumnLayout","heading":{"name":"Preparing the Lesson"},"leftColumn":{"leftColumn":"## Teacher Preparation\n\nRead over the pupil worksheet\n\n> ### Resources\n>You can find the Kurono user guide, cheat sheet and challenge resources on your Kurono dashboard: https://www.codeforlife.education/teach/kurono/dashboard"},"rightColumn":{"rightColumn":"## Timing\n\nOne lesson of approximately 50 minutes.\n\n> ### Pupils’ prior experience\n>Pupils should be familiar with Python programming,\nincluding the use of:\n* Variables\n* Assignment\n* Selection\n* Functions and procedures (subroutines)\n* Parameters\n* Loops"}},{"__typename":"ContentfulFullWidthText","heading":{"name":"Lesson Details"},"content":{"content":"This lesson builds on the previous lessons and allows your pupils to further investigate the use of selection, loops, arrays and subroutines. There are opportunities for discussing efficiency, local and global variables."}},{"__typename":"ContentfulFullWidthText","heading":{"name":"Direction Control"},"content":{"content":"Pupils might have commented that they cannot easily control the direction their avatar takes. This has a great deal to do with the turn-based approach: the avatar is not designed to remember a fixed list of directions to take but rather to react to what is going on at each turn.\n\nThe new subroutine, `world_state.scan_nearby()` returns a list of nearby artefacts. You need to pass in the avatar location to scan within the avatar radius. The first artefact in the list is the closest.\n\nThere is also a new action, `MoveTowardsAction()`. You need to send this action an artefact to head towards.\n\nThe starter code demonstrates this.\n\n```python\ndef next_turn(world_state, avatar_state):\n    # scan_nearby() returns a list of the nearest artefacts\n    nearby = world_state.scan_nearby(avatar_state.location)\n\n    # Head towards the nearest artefact\n    nearest = nearby[0]\n\n    return MoveTowardsAction(nearest)\n```\n\nAsk pupils to try this starter code. They will notice that their avatar is moving towards the artefact. It will not pick anything up though, since that code is not there yet.\n\nTherefore, they now need to change this code to incorporate the pick up action. The reminder given to pupils is:\n\n```python\ncurrent_cell = world_state.get_cell(avatar_state.location)\nif current_cell.has_artefact():\n    action = PickupAction()\n\nreturn action\n```\n\nTheir code must return an action, in this case it will be a `PickupAction` or a `MoveTowardsAction`. Here is a suggested solution:\n\n```python\ndef next_turn(world_state, avatar_state):\n    avatar_location = avatar_state.location\n    current_cell = world_state.get_cell(avatar_location)\n    if current_cell.has_artefact():\n        action = PickupAction()\n    else:\n        nearby = world_state.scan_nearby(avatar_location)\n        nearest = nearby[0]\n        action = MoveTowardsAction(nearest)\n\n    return action\n```"}},{"__typename":"ContentfulFullWidthText","heading":{"name":"Pick up five artefacts"},"content":{"content":"When pupils pick up an artefact, it will disappear from the map and be moved to their backpack. They can check the number of items in their backpack using this code:\n\n```python\nmy_backpack = avatar_state.backpack\nprint(\"Picked up\", len(my_backpack), \"artefacts\")\n```\n\nThis challenge asks pupils to find five artefacts and output a message when they have achieved this. `my_backpack` is a list of artefact objects so pupils can iterate (loop) over the list and examine each artefact in turn.\n\n__Potential pitfalls:__\n\nAny variables defined in a subroutine are __local__ to that subroutine and are reset when the subroutine is next called. This means that pupils cannot keep a value in a variable between turns. They don’t need to use a local variable to remember the number of items in their backpack because they can check the length at any time. However, some might try this and be confused. They can use global variables if they wish E.g.\n\n```python\ng_turns = 0\ndef next_turn(world_state, avatar_state):\n    global g_turns\n    g_turns = g_turns + 1\n    print(\"I have had\", g_turns, \"turns\")\n```\n\n```console\nI have had 3 turns\nI have had 4 turns\nI have had 5 turns\nI have had 6 turns\n```\n\n__Example solution__\n\n```python\ndef next_turn(world_state, avatar_state):\n    my_backpack = avatar_status.backpack\n    if len(my_backpack) == 5:\n        print(\"I have five items in my backpack, I win!\")\n\n    if current_cell.has_artefact():\n        action = PickupAction()\n    else:\n        nearby = world_state.scan_nearby()\n        nearest = nearby[0]\n        action = MoveTowardsAction(nearest)\n\n    return action\n```"}},{"__typename":"ContentfulFullWidthText","heading":{"name":"Types of Artefact"},"content":{"content":"Important note: the code on the pupils’ worksheets will crash if they haven’t picked up any artefacts. It is important that pupils consider how lists work if they are confused by this.\n\n```python\nartefact = my_backpack[0]\nprint(\"The first one is\", artefact.type)\n```\n\n__Part 1__\n\nIn this part of the challenge, pupils only need to output what is in their backpack.\n\n```python\ndef next_turn(world_state, avatar_state):\n    my_backpack = avatar_state.backpack\n    if len(my_backpack) == 5:\n        # Print out the artefact details\n        index = 0\n        while index < len(avatar_state.backpack):\n            artefact = my_backpack[index]\n            print(\"Artefact type\", artefact.type)\n            index = index + 1\n\n    if current_cell.has_artefact():\n        action = PickupAction()\n    else:\n        nearby = world_state.scan_nearby(avatar_state.location)\n        nearest = nearby[0]\n        action = MoveTowardsAction(nearest)\n\n    return action\n ```\n\n __Part 2__\n\nThe second part of the challenge asks pupils to tally up the different types of artefacts found. This selection in a loop is an important standard counting algorithm.\n\n```python\ndef next_turn(world_state, avatar_state):\n    my_backpack = avatar_state.backpack\n    if len(my_backpack) == 5:\n        # Print out the artefact details\n        index = 0\n        key_count = 0\n        chest_count = 0\n        while index < len(avatar_state.backpack):\n            artefact = my_backpack[index]\n            if artefact.type == world_state.artefact_types.KEY:\n                key_count += 1\n            elif artefact.type == world_state.artefact_types.CHEST:\n                chest_count += 1\n            index = index + 1\n        print(\"I have {0} keys and {1} chests.\".format(key_count, chest_count))\n\n    if current_cell.has_artefact():\n        action = PickupAction()\n    else:\n        nearby = world_state.scan_nearby(avatar_state.location)\n        nearest = nearby[0]\n        action = MoveTowardsAction(nearest)\n\n    return action\n ```\n\nThese tasks have allowed pupils to further explore the use of selection and subroutines, as well as interacting with the Kurono API. In the next worksheet, pupils will be able to scan areas of the map to look for artefacts and start to discover different types of artefact."}}]}},"pageContext":{"contentful_id":"4MuzUvy6SoowOyWrnFSycv"}}}